---
title: "Season 5 Episode 11 | Predicting Loan Payback"
author: "Göktürk Çolak"
date: "2025-11-02"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Data Upload and Preprocessing

```{r}
# libraries
library(tidyverse)

# setting up the directory
setwd("Github/kaggle-playground-series/Season 5 Episode 11")

# uploading the files
train <- read_csv("data/train.csv")
test <- read_csv("data/test.csv")
sample_submission <- read_csv("data/sample_submission.csv")

train <- train %>% 
  mutate(loan_paid_back = as.factor(loan_paid_back)) 

levels(train$loan_paid_back)
```

# Exploratory Data Analysis

```{r}
train %>% 
  ggplot( aes(x = credit_score, fill = loan_paid_back)) +
  geom_density(alpha = 0.5) +
  labs(title = "Credit Score Distribution by Payback Status")


train %>% 
  ggplot(aes(x = employment_status, fill = loan_paid_back)) +
  geom_bar(position = "fill") +
  labs(title = "Payback Rate by Employment Status", y = "Proportion") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


train %>% 
  ggplot(aes(x = credit_score, fill = loan_paid_back)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~employment_status) +
  labs(title = "Credit Score Distribution by Employment Status and Payback")



# Note: Omit outliers since IQR is low (0.084) - DONE
# summary(train$debt_to_income_ratio)
Q1_dti <- quantile(train$debt_to_income_ratio, 0.25)
Q3_dti <- quantile(train$debt_to_income_ratio, 0.75)
IQR_dti <- IQR(train$debt_to_income_ratio)

lower_bound_dti <- Q1_dti - 1.5 * IQR_dti
upper_bound_dti <- Q3_dti + 1.5 * IQR_dti

# Filter out outliers
train_clean <- train %>%
  filter(debt_to_income_ratio >= lower_bound_dti & debt_to_income_ratio <= upper_bound_dti)


train_clean %>% 
  ggplot(aes(x = debt_to_income_ratio, fill = loan_paid_back)) +
  geom_density(alpha = 0.3) +
  labs(title = "Debt-to-Income Ratio by Payback Status (Outliers Removed)")


# ? Not sure, model may catch some signals
train %>% 
  ggplot(aes(x = loan_purpose, fill = loan_paid_back)) +
  geom_bar(position = "fill") +
  labs(title = "Payback Rate by Loan Purpose", y = "Proportion") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


# A1:B5 ~ Safe
# C1:C5 ~ Moderate
# D1:F5 ~ Dangerous
train %>% 
  ggplot(aes(x = grade_subgrade, fill = loan_paid_back)) +
  geom_bar(position = "fill") +
  labs(title = "Payback Rate by Loan Grade/Subgrade", y = "Proportion") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


# corrplot ---------------------------------------------------------------------
library(corrplot)

numerical_vars <- train %>% 
  select(annual_income, debt_to_income_ratio, credit_score, loan_amount, interest_rate, loan_paid_back) %>%
  mutate(loan_paid_back = as.numeric(as.character(loan_paid_back)))

cor_matrix <- cor(numerical_vars, use = "complete.obs")

corrplot(cor_matrix, method = "color", type = "upper")

# corrplot ends ----------------------------------------------------------------

# Interest Rate
Q1_interest <- quantile(train$interest_rate, 0.25)
Q3_interest <- quantile(train$interest_rate, 0.75)
IQR_interest <- IQR(train$interest_rate)

lower_bound_interest <- Q1_interest - 1.5 * IQR_interest
upper_bound_interest <- Q3_interest + 1.5 * IQR_interest

train_clean <- train %>%
  filter(interest_rate >= lower_bound_interest & interest_rate <= upper_bound_interest)

train_clean %>% 
  ggplot(aes(interest_rate, fill = loan_paid_back)) +
  geom_density(alpha = .3)


### ADDITIONS --- NEW

# Check class distribution
class_dist <- prop.table(table(train$loan_paid_back))
print(paste("Class 0:", round(class_dist[1], 3)))
print(paste("Class 1:", round(class_dist[2], 3)))

# Since imbalance is 0.201 to 0.799, set scale_pos_weight properly
# For XGBoost: scale_pos_weight = number of negative class / number of positive class
if (class_dist[1] > 0.7 | class_dist[2] > 0.7) {
  scale_ratio <- sum(train$loan_paid_back == 0) / sum(train$loan_paid_back == 1)
  print(paste("Setting scale_pos_weight to:", round(scale_ratio, 3)))
  # This will be approximately 0.251 (since 20.1%/79.9% ≈ 0.251)
}



# Test Debt + Credit Score Interaction
train %>%
  mutate(
    debt_credit_risk = case_when(
      debt_to_income_ratio > 0.4 & credit_score < 650 ~ "High_Debt_Poor_Credit",
      debt_to_income_ratio > 0.4 & credit_score >= 650 ~ "High_Debt_Good_Credit",
      debt_to_income_ratio <= 0.4 & credit_score < 650 ~ "Low_Debt_Poor_Credit",
      TRUE ~ "Low_Debt_Good_Credit"
    )
  ) %>%
  ggplot(aes(x = debt_credit_risk, fill = loan_paid_back)) +
  geom_bar(position = "fill") +
  labs(title = "Debt & Credit Score Combinations") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# -> Hypothesis: Higher payment/income ratio = riskier

# Actual Loan Purpose Payback Rates - sorted from lowest to highest
train %>%
  group_by(loan_purpose) %>%
  summarise(payback_rate = mean(as.numeric(as.character(loan_paid_back)))) %>%
  mutate(loan_purpose = fct_reorder(loan_purpose, payback_rate)) %>%
  ggplot(aes(x = loan_purpose, y = payback_rate)) +
  geom_col(fill = "steelblue") +
  labs(title = "Actual Loan Purpose Payback Rates (Lowest to Highest)", 
       x = "Loan Purpose", y = "Payback Rate") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_y_continuous(labels = scales::percent_format()) +
  geom_text(aes(label = paste0(round(payback_rate * 100, 1), "%")), 
            vjust = -0.5, size = 3)

# Test Loan Purpose Risk Tiers with actual categories
train %>%
  mutate(
    purpose_risk = case_when(
      loan_purpose %in% c("Education", "Medical", "Vacation") ~ "Low_Risk",
      loan_purpose %in% c("Debt consolidation", "Car", "Other") ~ "Medium_Risk", 
      loan_purpose %in% c("Business", "Home") ~ "High_Risk")
  ) %>%
  ggplot(aes(x = purpose_risk, fill = loan_paid_back)) +
  geom_bar(position = "fill") +
  labs(title = "Loan Purpose Risk Tiers vs Payback Rate") +
  theme_minimal()

# -> Hypothesis: Some purposes are inherently riskier

# 4. Debt + Credit Score Interaction
train %>%
  mutate(
    debt_credit_risk = ifelse(debt_to_income_ratio > 0.4 & credit_score < 650, "High_Risk", "Normal")
  ) %>%
  ggplot(aes(x = debt_credit_risk, fill = loan_paid_back)) +
  geom_bar(position = "fill") +
  labs(title = "High Debt + Poor Credit Combination")

# Hypothesis: This combination is particularly dangerous

# 5. Credit Utilization Concept
train %>%
  mutate(
    credit_utilization = debt_to_income_ratio / credit_score * 1000
  ) %>%
  filter(credit_utilization < 5) %>% # Remove outliers
  ggplot(aes(x = credit_utilization, fill = loan_paid_back)) +
  geom_density(alpha = 0.5) +
  labs(title = "Credit Utilization Metric vs Payback")

# Hypothesis: Higher utilization = higher risk



```

# Feature Engineering

```{r}
# Load libraries
library(dplyr)
library(caret)
library(xgboost)
library(catboost)
library(pROC)

# Apply the feature engineering to create modeling dataset
train_model <- train %>%
  mutate(
    # Fix target variable naming
    loan_paid_back = factor(loan_paid_back,
                           levels = c(0, 1),
                           labels = c("Not_Paid", "Paid")),
    
    # Original features
    credit_risk_tier = factor(case_when(
      credit_score <= 650 ~ "High_Risk",
      credit_score > 650 & credit_score < 700 ~ "Medium_Risk", 
      credit_score >= 700 ~ "Low_Risk"
    )),
    
    employment_stability = factor(case_when(
      employment_status %in% c("Employed", "Retired", "Self-employed") ~ "Stable",
      employment_status == "Student" ~ "Moderate", 
      employment_status == "Unemployed" ~ "Unstable"
    )),
    
    high_risk_combination = as.factor(ifelse(
      employment_status %in% c("Retired", "Student") & credit_score <= 650, 1, 0
    )),
    
    loan_risk_tier = factor(case_when(
      grade_subgrade %in% c(paste0("A", 1:5), paste0("B", 1:5)) ~ "Safe",
      grade_subgrade %in% paste0("C", 1:5) ~ "Moderate",
      TRUE ~ "Dangerous"
    )),
    
    interest_rate_risk = case_when(
      interest_rate < 12.5 ~ "Low_Risk",
      interest_rate >= 12.5 ~ "High_Risk"
    ),
    
    # NEW STRONG FEATURES
    debt_credit_profile = factor(case_when(
      debt_to_income_ratio > 0.4 & credit_score < 650 ~ "High_Debt_Poor_Credit",
      debt_to_income_ratio > 0.4 & credit_score >= 650 ~ "High_Debt_Good_Credit",
      debt_to_income_ratio <= 0.4 & credit_score < 650 ~ "Low_Debt_Poor_Credit", 
      TRUE ~ "Low_Debt_Good_Credit"
    )),
    
    payment_to_income_ratio = (loan_amount * interest_rate/100 / 12) / (annual_income / 12),
    credit_utilization = debt_to_income_ratio / credit_score * 1000,
    purpose_risk = case_when(
      loan_purpose %in% c("Education", "Medical", "Vacation") ~ "Low_Risk",
      loan_purpose %in% c("Debt consolidation", "Car", "Other") ~ "Medium_Risk", 
      loan_purpose %in% c("Business", "Home") ~ "High_Risk")
  ) %>%
  # Remove extreme payment-to-income ratios ONLY FROM TRAINING
  filter(payment_to_income_ratio < 0.5) %>%
  na.omit()
```

# Logistic Regression

```{r}
# Set up and run 5-fold cross-validation for Logistic Regression (Baseline only)
set.seed(123)
ctrl <- trainControl(
  method = "cv",
  number = 5,
  summaryFunction = twoClassSummary,
  classProbs = TRUE,
  verboseIter = TRUE
)

# 1. Logistic Regression Model with ALL features
cv_model <- train(
  loan_paid_back ~ credit_score + annual_income + 
    debt_to_income_ratio + loan_amount + interest_rate +
    credit_risk_tier + employment_stability + high_risk_combination +
    loan_risk_tier + interest_rate_risk +
    debt_credit_profile + payment_to_income_ratio + credit_utilization + purpose_risk,  # ADDED NEW FEATURES
  data = train_model,
  method = "glm", 
  family = "binomial",
  trControl = ctrl,
  metric = "ROC"
)

print(paste("Logistic Regression CV AUC:", round(mean(cv_model$results$ROC), 4)))
```

# XGBoost

```{r}
# 2. XGBoost with ALL features including new ones
train_features <- train_model %>%
  select(credit_score, annual_income, debt_to_income_ratio, loan_amount, 
         interest_rate, credit_risk_tier, employment_stability, 
         high_risk_combination, loan_risk_tier, interest_rate_risk,
         debt_credit_profile, payment_to_income_ratio, credit_utilization, purpose_risk) %>%  # ADDED NEW FEATURES
  model.matrix(~ . - 1, data = .)

train_label <- as.numeric(train_model$loan_paid_back == "Paid")

# Create XGBoost specific data structure
dtrain <- xgb.DMatrix(data = train_features, label = train_label)

# Set parameters with class imbalance handling
params <- list(
  objective = "binary:logistic",
  eval_metric = "auc",
  eta = 0.05,
  max_depth = 7,
  min_child_weight = 2,
  subsample = 0.8,
  colsample_bytree = 0.8,
  scale_pos_weight = sum(train_label == 0) / sum(train_label == 1)
)

# Train with early stopping
xgb_cv <- xgb.cv(
  params = params,
  data = dtrain,
  nrounds = 1000,
  nfold = 5,
  early_stopping_rounds = 50,
  verbose = TRUE,
  print_every_n = 100
)

# Train final XGBoost model on full training data
final_xgb <- xgb.train(
  params = params,
  data = dtrain,
  nrounds = xgb_cv$best_iteration,
  verbose = 1
)

print(paste("XGBoost CV AUC:", xgb_cv$evaluation_log$test_auc_mean[xgb_cv$best_iteration]))
```

# Catboost

```{r}
# 3. CatBoost - WORKING approach with manual categorical encoding
# Convert categorical features to numeric codes manually
train_data_cb <- train_model %>%
  mutate(
    credit_risk_tier_num = as.numeric(factor(credit_risk_tier)),
    employment_stability_num = as.numeric(factor(employment_stability)),
    high_risk_combination_num = as.numeric(factor(high_risk_combination)),
    loan_risk_tier_num = as.numeric(factor(loan_risk_tier)),
    interest_rate_risk_num = as.numeric(factor(interest_rate_risk)),
    debt_credit_profile_num = as.numeric(factor(debt_credit_profile)),
    purpose_risk_num = as.numeric(factor(purpose_risk))
  ) %>%
  select(credit_score, annual_income, debt_to_income_ratio, loan_amount,
         interest_rate, payment_to_income_ratio, credit_utilization,
         credit_risk_tier_num, employment_stability_num, high_risk_combination_num,
         loan_risk_tier_num, interest_rate_risk_num, debt_credit_profile_num, purpose_risk_num) %>%
  as.matrix()

train_label_catboost <- as.numeric(train_model$loan_paid_back == "Paid")

# Create CatBoost pool (no categorical features specified)
train_pool <- catboost.load_pool(data = train_data_cb, label = train_label_catboost)

# Set CatBoost parameters
catboost_params <- list(
  iterations = 1000,
  learning_rate = 0.05,
  depth = 7,
  loss_function = 'Logloss',
  eval_metric = 'AUC',
  verbose = 100,
  early_stopping_rounds = 50,
  class_weights = list(1, sum(train_label == 0) / sum(train_label == 1)),
  random_seed = 123
)

# Train final CatBoost model
final_catboost <- catboost.train(
  learn_pool = train_pool,
  params = catboost_params
)

# Manual CV
set.seed(123)
folds <- createFolds(train_model$loan_paid_back, k = 5)
catboost_auc_scores <- c()

for(i in 1:5) {
  train_idx <- unlist(folds[-i])
  test_idx <- folds[[i]]
  
  train_fold <- train_data_cb[train_idx, ]
  train_label_fold <- train_label_catboost[train_idx]
  test_fold <- train_data_cb[test_idx, ]
  test_label_fold <- train_label_catboost[test_idx]
  
  train_pool_fold <- catboost.load_pool(data = train_fold, label = train_label_fold)
  test_pool_fold <- catboost.load_pool(data = test_fold, label = test_label_fold)
  
  catboost_fold <- catboost.train(learn_pool = train_pool_fold, test_pool = test_pool_fold, params = catboost_params)
  preds <- catboost.predict(catboost_fold, test_pool_fold, prediction_type = "Probability")
  fold_auc <- pROC::auc(pROC::roc(test_label_fold, preds))
  catboost_auc_scores <- c(catboost_auc_scores, fold_auc)
  
  print(paste("Fold", i, "CatBoost AUC:", round(fold_auc, 4)))
}

print(paste("CatBoost CV AUC:", round(mean(catboost_auc_scores), 4)))
```

# Test Features

```{r}
# Prepare test set with ALL features - NO FILTERING!
test_clean <- test %>%
  mutate(
    credit_risk_tier = factor(case_when(
      credit_score <= 650 ~ "High_Risk",
      credit_score > 650 & credit_score < 700 ~ "Medium_Risk", 
      credit_score >= 700 ~ "Low_Risk"
    )),
    employment_stability = factor(case_when(
      employment_status %in% c("Employed", "Retired", "Self-employed") ~ "Stable",
      employment_status == "Student" ~ "Moderate", 
      employment_status == "Unemployed" ~ "Unstable"
    )),
    high_risk_combination = as.factor(ifelse(
      employment_status %in% c("Retired", "Student") & credit_score <= 650, 1, 0
    )),
    loan_risk_tier = factor(case_when(
      grade_subgrade %in% c(paste0("A", 1:5), paste0("B", 1:5)) ~ "Safe",
      grade_subgrade %in% paste0("C", 1:5) ~ "Moderate",
      TRUE ~ "Dangerous"
    )),
    interest_rate_risk = case_when(
      interest_rate < 12.5 ~ "Low_Risk",
      interest_rate >= 12.5 ~ "High_Risk"
    ),
    # NEW FEATURES FOR TEST SET
    debt_credit_profile = factor(case_when(
      debt_to_income_ratio > 0.4 & credit_score < 650 ~ "High_Debt_Poor_Credit",
      debt_to_income_ratio > 0.4 & credit_score >= 650 ~ "High_Debt_Good_Credit",
      debt_to_income_ratio <= 0.4 & credit_score < 650 ~ "Low_Debt_Poor_Credit", 
      TRUE ~ "Low_Debt_Good_Credit"
    )),
    payment_to_income_ratio = (loan_amount * interest_rate/100 / 12) / (annual_income / 12),
    credit_utilization = debt_to_income_ratio / credit_score * 1000,
    purpose_risk = case_when(
      loan_purpose %in% c("Education", "Medical", "Vacation") ~ "Low_Risk",
      loan_purpose %in% c("Debt consolidation", "Car", "Other") ~ "Medium_Risk", 
      loan_purpose %in% c("Business", "Home") ~ "High_Risk")
  )

# Prepare test features for each model with ALL features
# For XGBoost
test_features_xgb <- test_clean %>%
  select(credit_score, annual_income, debt_to_income_ratio, loan_amount, 
         interest_rate, credit_risk_tier, employment_stability, 
         high_risk_combination, loan_risk_tier, interest_rate_risk,
         debt_credit_profile, payment_to_income_ratio, credit_utilization, purpose_risk) %>%  # ADDED NEW FEATURES
  model.matrix(~ . - 1, data = .)

dtest_xgb <- xgb.DMatrix(data = test_features_xgb)

# For CatBoost (only numerical features to avoid errors)
# Prepare test set for CatBoost with manual categorical encoding
test_data_cb <- test_clean %>%
  mutate(
    credit_risk_tier_num = as.numeric(factor(credit_risk_tier)),
    employment_stability_num = as.numeric(factor(employment_stability)),
    high_risk_combination_num = as.numeric(factor(high_risk_combination)),
    loan_risk_tier_num = as.numeric(factor(loan_risk_tier)),
    interest_rate_risk_num = as.numeric(factor(interest_rate_risk)),
    debt_credit_profile_num = as.numeric(factor(debt_credit_profile)),
    purpose_risk_num = as.numeric(factor(purpose_risk))
  ) %>%
  select(credit_score, annual_income, debt_to_income_ratio, loan_amount,
         interest_rate, payment_to_income_ratio, credit_utilization,
         credit_risk_tier_num, employment_stability_num, high_risk_combination_num,
         loan_risk_tier_num, interest_rate_risk_num, debt_credit_profile_num, purpose_risk_num) %>%
  as.matrix()

test_pool <- catboost.load_pool(data = test_data_cb)
```

# Submission files

```{r}
# Generate predictions from all models
xgb_predictions <- predict(final_xgb, newdata = dtest_xgb)
catboost_predictions <- catboost.predict(final_catboost, test_pool, prediction_type = "Probability")

# Create submission files
# 1. XGBoost (your best model)
xgb_submission <- data.frame(
  id = test$id,
  loan_paid_back = xgb_predictions
)
write.csv(xgb_submission, "xgb_submission.csv", row.names = FALSE)

# 2. CatBoost 
catboost_submission <- data.frame(
  id = test$id,
  loan_paid_back = catboost_predictions
)
write.csv(catboost_submission, "catboost_submission.csv", row.names = FALSE)

# 3. XGBoost + CatBoost Ensemble (only if CatBoost performs well)
if(mean(catboost_auc_scores) > 0.91) {  # Only ensemble if CatBoost is decent
  ensemble_predictions <- (xgb_predictions * 0.7 + catboost_predictions * 0.3)
  ensemble_submission <- data.frame(
    id = test$id,
    loan_paid_back = ensemble_predictions
  )
  write.csv(ensemble_submission, "ensemble_submission.csv", row.names = FALSE)
}

print(paste("Submission rows check - XGBoost:", nrow(xgb_submission)))
print(paste("Submission rows check - CatBoost:", nrow(catboost_submission)))

# Model Performance Summary
print("=== MODEL PERFORMANCE SUMMARY ===")
print(paste("Logistic Regression CV AUC:", round(mean(cv_model$results$ROC), 4)))
print(paste("XGBoost CV AUC:", round(xgb_cv$evaluation_log$test_auc_mean[xgb_cv$best_iteration], 4)))
print(paste("CatBoost CV AUC:", round(mean(catboost_auc_scores), 4)))

# Feature importance for insight
importance_matrix <- xgb.importance(model = final_xgb)
print("XGBoost Feature Importance:")
print(importance_matrix[1:15, ])

print("All submission files created: xgb_submission.csv, catboost_submission.csv, ensemble_submission.csv")
```

